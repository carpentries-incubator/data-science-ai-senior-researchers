<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.269">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Practical Considerations: Reporting Results</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
</style>


<script src="07-Practical Considerations:Reporting-results_files/libs/clipboard/clipboard.min.js"></script>
<script src="07-Practical Considerations:Reporting-results_files/libs/quarto-html/quarto.js"></script>
<script src="07-Practical Considerations:Reporting-results_files/libs/quarto-html/popper.min.js"></script>
<script src="07-Practical Considerations:Reporting-results_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="07-Practical Considerations:Reporting-results_files/libs/quarto-html/anchor.min.js"></script>
<link href="07-Practical Considerations:Reporting-results_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="07-Practical Considerations:Reporting-results_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="07-Practical Considerations:Reporting-results_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="07-Practical Considerations:Reporting-results_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="07-Practical Considerations:Reporting-results_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Practical Considerations: Reporting Results</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="reporting-results-from-machine-learning-pipelines" class="level3">
<h3 class="anchored" data-anchor-id="reporting-results-from-machine-learning-pipelines">Reporting results from machine learning pipelines</h3>
<p>As with any other statistical analysis you can expect to report various metrics that communicate your results obtained from a machine learning (ML) pipeline. You may have heard of p-values, adjusted R-squared and the t-statistic used in methods such as a t-test or chi-squared-test. Supervised (regression and classification) and unsupervised ML algorithms have distinct metrics that you will be reporting:</p>
<ul>
<li>Supervised algorithms:
<ul>
<li>Accuracy</li>
<li>Sensitivity</li>
<li>Specificity</li>
<li>Precision</li>
<li>Recall</li>
<li>F1 score</li>
<li>Mean Squared Error (MSE)</li>
<li>Root Mean Squared Error (RMSE)</li>
<li>Mean Absolute Error (MAE)</li>
</ul></li>
<li>Unsupervised algorithms
<ul>
<li>Total within sum of squared error</li>
<li>Gap statistic</li>
<li>Silhouette value</li>
<li>Akaike Information Criterion</li>
</ul></li>
</ul>
<section id="reporting-results-in-regression-supervised" class="level4">
<h4 class="anchored" data-anchor-id="reporting-results-in-regression-supervised">Reporting results in regression (supervised)</h4>
<p>While there are many techniques that fall under the term “regression” such as linear/multiple, logistic, poisson or Cox proportional-hazards, they all aim to fit a line of best fit to the data, and so here we describe metrics that relate to describing how “good” a line of best fit is.</p>
<p>Most regression metrics are derived from a “residual” - the distance of a line of fit to a data point. Some some data points fall below the line of fit and some fall above the line of fit, so to ensure the residuals don’t cancel out, we take the square of the residual and arrived at the “sum of squared residuals”.</p>
<p align="center">
<img src="../fig/mse.png" alt="drawing" width="550">
</p>
<p>In the image above we can see that for a line that has been fitted to the data with linear regression (blue) has quite small residuals (red) compared to the larger residuals of a line comprised simply of the mean height (green). The Mean Squared Error (MSE) is simply the sum of squared residuals divided by the number of data points. By taking the root of the MSE we get the Root Mean Squared Error (RMSE). If you were to take the absolute value of the residual instead of the squared residual then you will arrive at the Mean Absolute Error (MAE).</p>
<p>You might point out that each of these three measures appear quite similar, however if you consider that case of having a higher number of outliers, the RMSE or MAE are better metrics to use over MSE because the MSE will be inflated due to squaring the large residuals of outliers.</p>
</section>
<section id="reporting-results-in-classification-supervised" class="level4">
<h4 class="anchored" data-anchor-id="reporting-results-in-classification-supervised">Reporting results in classification (supervised)</h4>
<p>Supervised learning can be divided into two types of problems: regression and classification. Regression is used for the prediction of continuous variables, and classification aims to classify something into specific categories, and often into just two categories (binary). Here, we mainly focus on classification tasks.</p>
<p>When training a supervised algorithm we can compare its predictions to the <em>ground truth</em> and therefore say if it is correct or incorrect. These leads to the first staple of reporting in supervised learning: <strong>the confusion matrix</strong>.</p>
<section id="training-testing-and-the-confusion-matrix" class="level5">
<h5 class="anchored" data-anchor-id="training-testing-and-the-confusion-matrix">Training, Testing and the Confusion matrix</h5>
<p>When we report results from supervised classification, we are only interested in calculating metrics from the test data - the training data is used only to train the model. From the test data, we can use our trained model to make predictions and compare to the actual classes of each item in the test set. For N number of classes (e.g.&nbsp;N=2 for predicting cancer vs no cancer), a confusion matrix is an NxN matrix that records how many the algorithm classified correctly and incorrectly by visualizing the actual classes against the predicted classes.</p>
<p><img src="https://i.pinimg.com/736x/7d/49/d5/7d49d532ebbdd5247f121adfbe77b688.jpg" class="img-fluid"></p>
<p>However many classes there are, a confusion matrix reports 4 types of outcome:</p>
<ul>
<li><strong>True Positives</strong> - The classifier predicts a positive case i.e.&nbsp;cancer, and that person does actually have cancer.</li>
<li><strong>True Negative</strong> - The classifier predicts a negative case i.e.&nbsp;<em>no</em> cancer, and that person doesn’t actually have cancer.</li>
<li><strong>False Positives</strong> - The classifier predicts a positive case i.e.&nbsp;cancer, but that person doesn’t actually have cancer.</li>
<li><strong>True Positives</strong> - The classifier predicts a negative case i.e.&nbsp;<em>no</em> cancer, but that person does actually have cancer.</li>
</ul>
<p>These 4 components can be used to calculate the most common metrics in supervised classification: accuracy, sensitivity and specificity.</p>
<ul>
<li><strong>Accuracy</strong> - The percentage of correct classifications in the dataset.</li>
<li><strong>Sensitivity</strong> - The percentage of positive cases correctly identified. Sometimes called the <em>True Positive Rate (TPR)</em>.</li>
<li><strong>Specificity</strong> - The percentage of negative cases correctly identified. Sometimes called the <em>True Negative Rate (TNR)</em></li>
</ul>
<p>Performance metrics are problem-dependent. For example, if your primary aim is to pick up as many COVID-19 cases as possible to reduce spread, <em>sensitivity</em> will tell you how well your algorithm does, not accuracy. If it is important to be as sure as possible that someone will likely develop disease because it will likely cause harm in other ways i.e.&nbsp;developing mental health issues due a diagnosis of dementia, <em>specificity</em> can help you prioritize when to label someone with the disease. Therefore, it is important to know how to trade sensitivity with specificity. This is where the <strong>Receiver Operator Characteristic (ROC) Curve</strong> can help.</p>
<p>In some use-cases, such as <em>information retrieval tasks</em>, a task where you want to retrieve relevant documents or records from the population, we often talk about the <strong>precision</strong> and <strong>recall</strong> of a model rather than specificity and sensitivity. For example, if we wrote an ML algorithm to scan clinic letters for people with epilepsy, we know that most of the population do not have epilepsy and so “no epilepsy” won’t be explicitly recorded. The recall is described by out of all the <em>possible</em> epilepsies in the population, what percentage does the algorithm pick up? This is exactly the same as sensitivity! This tells us the model’s ability to recall as many epilepsies as possible from the population. However, we can also ask how many of just the people in the population who have known epilepsy, how many are identified as such by the model? This is this <em>precision</em> of the model and unlike recall being the same as sensitivity, precision is not the same as specificity.</p>
</section>
<section id="k-crossfold-validation" class="level5">
<h5 class="anchored" data-anchor-id="k-crossfold-validation">K Crossfold Validation</h5>
<p>Instead of using a simple train/test split to report our results, it is common to use a method called <strong>crossfold validation</strong>. Here we can split the data into X% training data and Y% for test data (an 80/20 split is quite common) <strong>K</strong> times (K=10 is also quite common). Note that when we talk about K crossfold validation the “test sets” in each fold are called <em>validation sets</em>. The reason for doing K crossfold validation is because if we only chose K=1 it might turn out that the test data by chance contains some unrepresentative data points compared to the data as a whole (or more importantly in a real world population scenario). So by repeating the sampling process we aim to use all data point in at least 1 test set. Another reason to do this is to help select the best hyperparameter values during training (again, we might get lucky or unlucky with just one training set).</p>
<p>But there are two extremely important things to remember when using K crossfold validation. The first is that we only ever split the training data up into subsequent K splits i.e.&nbsp;we should always hold out a completely separate test set that never gets used during crossfold validation and biases the training process. Therefore you should think of K crossfold validation as something that happens during training. This leads onto the second important thing to note: the validation sets from each fold are <strong>not</strong> your final results - they are merely there to show you how stable a model is and to find the best hyperparameter values. Once we know our values and stability we discard all of the individual folds and re-train our model with all of the training data, and then use the held out test data to report our results.</p>
<p>The following diagram should help you visualize an ML experiment that used K crossfold validation:</p>
<p><img src="https://scikit-learn.org/stable/_images/grid_search_cross_validation.png" class="img-fluid"></p>
</section>
<section id="roc-curves" class="level5">
<h5 class="anchored" data-anchor-id="roc-curves">ROC Curves</h5>
<p>In addition to predictions (e.g.&nbsp;“disease” or “not disease” labels), some ML algorithms provide a numerical score (in some cases a probability) that measures the quality of the prediction. Whatever this numerical range is, we can choose a threshold of when to classify someone as having a disease. If we move the threshold one way we will increase sensitivity, and if we move it the other direction we will increase specificity. This means we could visualize all the resulting sensitivities and specificities for each threshold we choose. This powerful visualization is called a <strong>ROC Curve</strong> and we can use it to choose a threshold for a desired sensitivity, knowing how much specificity we would have to sacrifice.</p>
<img src="../fig/ROC.png" alt="drawing" width="350">
<p></p>
<table class="table">
<colgroup>
<col style="width: 100%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: center;">Receiver Operator Characteristic (ROC) Curve. The y-axis shows True Positive Rate (TPR), also called sensitivity or recall. The x-axis is False Positive Rate (FPR) or 1 - specificity. The ROC curve plots the FPR against TPR for various thresholds, i.e., the points along the blue curve.</td>
</tr>
</tbody>
</table>
<p>The orange dashed line shows the ROC curve of a purely random classifier. For such classifiers, <code>sensitivity = 1 - specificity</code> (or TPR = FPR) at all points. The blue curve shows the TPR vs FPR at all threshold values, and the closer a ROC curve is to the top-left of the graph (TPR=1, FPR=0) better. We can also calculate the <em>Area Under the Curve (AUC)</em> that allows us to see the total aggregated measure of TPR and FPR over all thresholds and is often reported along with accuracy.</p>
<p align="center">
<img src="../fig/ROC2.png" alt="drawing" width="400">
</p>
<p>With consideration to the orange “line of chance”, we can draw the opposite (black line), where this line crosses the ROC curve and is the point that the default confusion matrix is calculated from. However, if we move the threshold, we can obtain a different confusion matrix. From the blue curve we have marked a further point on the graph - one that trades away some specificity for an increase in sensitivity. This point will provide us with different values in our confusion matrix in which we will see more True Positives, but also more False Positives.</p>
</section>
</section>
<section id="calibration-of-predictions-from-over-or-under-sampled-datasets" class="level4">
<h4 class="anchored" data-anchor-id="calibration-of-predictions-from-over-or-under-sampled-datasets">Calibration of predictions from over or under sampled datasets</h4>
<p>ROC curves are most effective when we have equal proportions of the classes i.e.&nbsp;balance. Most situations are not balanced i.e.&nbsp;only 1% of people have epilepsy, and so we need to be interested in optimizing on both sensitivity and precision (which of those classified as epilepsy are actually epilepsy and how many of the possible epilepsies can the algorithm detect). We can swap out the specificity (False Positive Rate) in the ROC Curve for precision and re-plot. This is more commonly known as a Precision-Recall Curve, where <em>Recall</em> is just another term for sensitivity or True Positive Rate.</p>
<p><img src="https://modtools.files.wordpress.com/2020/01/roc_pr-1.png?w=584" class="img-fluid"></p>
<p>In the previous chapter we considered approaches to deal with imbalanced data - namely random undersampling and SMOTE to improve accuracy. This gives rise to a problem in that these methods can greatly effect predicted class probabilities, and you might only be interested in the class probability rather than the binary decision (this is far more useful in the author’s opinion!). Logistic regression is a perfect example - it is just a regression technique until you impose a threshold of class probability to classify into a binary outcome. It is entirely possible to have a good “classifier” but still have strange predicted class probabilities i.e.&nbsp;after oversampling the majority class, the predicted probability profile distribution of healthy controls are artificially shifted closer to that of those who went on to develop some disease, but an appropriate threshold might still be able to discriminate between both groups well. The problem is that you could end up telling someone who might not ever develop the disease that they have a high probability of developing the disease, even though the class label predicts them not to develop it. Is there an all purpose method to ensure whatever probabilities the model outputs, we can assess and calibrate them to what we expect in the population?</p>
<p>#####The Brier Score</p>
<p>The Brier Score compares the difference (mean squared error) between the predicted probability distribution. We can quickly see if a model is over-estimating or underestimating risk in the population.</p>
<p><img src="../fig/brier.png" class="img-fluid"></p>
<p>We can see that the random forest classifier in the above image is not well calibrated to the reference (black dotted line) as it deviates far away at very low and very high probabilities, indicating that the model is favouring scoring someone as either very low risk or very high risk. In comparison the logistic regression model is better calibrated and more likely to predicted risk in those other than clear cut low or high risk (which in some cases describe the population accurately, hence an accurate classifier even though it is poorly calibrated). However, if your model <em>is</em> poorly calibrated you can scale the predicted probabilities using methods such as Isotonic Regression and Platt Scaling.</p>
<blockquote class="blockquote">
<p>Here are two interesting resources on risk calibration and the role of thresholds for classification: https://bmcmedicine.biomedcentral.com/articles/10.1186/s12916-019-1466-7 https://www.fharrell.com/post/classification/</p>
</blockquote>
</section>
<section id="reporting-results-in-unsupervised-analysis" class="level4">
<h4 class="anchored" data-anchor-id="reporting-results-in-unsupervised-analysis">Reporting results in <em>Un</em>supervised analysis</h4>
<p>While Supervised learning focusses on optimizing metrics such as accuracy, sensitivity and specificity, <em>Un</em>supervised learning doesn’t have the ground truth to compare predictions to. As mentioned in previous chapters, the aims of unsupervised learning is to allow an algorithm to find hidden groups, or clusters from the dataset and therefore we are interested in providing metrics that show us an appropriate number of hidden clusters.</p>
<section id="total-within-cluster-sum-of-squared-error" class="level5">
<h5 class="anchored" data-anchor-id="total-within-cluster-sum-of-squared-error">Total Within Cluster Sum of Squared Error</h5>
<p>Most algorithms require you to run the cluster analysis with different values of <em>K</em>, the number of clusters, and then calculate the error within each cluster by measuring the squared (and square rooted) distance between the each datapoint and it’s cluster center. We take the square root of the squared distance to avoid adding minus numbers. For example if we run the algorithm with 4 clusters we can calculate the error for each cluster, and sum them to get the <em>total within cluster sum of squared error</em>.</p>
<p align="center">
<img src="http://assets.datacamp.com/production/course_5966/datasets/elbow_plot.007.png" alt="drawing" width="500">
</p>
<p>It is up to you to try out different values of K and then comparing the total within cluster sum of squared error in which you are trying to find the value of K that minimizes the error. What values of K should be tried? Firstly it is pointless trying K=1 because you have not learned anything from the data. Secondly you would not set K=N, the number of datapoints because while this would end up with zero error (each datapoint is it’s own cluster so 0 distance between them), we also don’t learn anything. There needs to be a preferable range that is usually between K=2 to K=10. This may change in some cases e.g.&nbsp;using cluster analysis to determine how many unique patient pathways there might be for starting medication following a diagnosis - there are only a finite number of treatment regimes and so K would at least be limited by that upper bound. Once you have decide a range you will want to visualize your results</p>
</section>
<section id="elbow-plot" class="level5">
<h5 class="anchored" data-anchor-id="elbow-plot">Elbow plot</h5>
<p>A common visualization of error analysis in unsupervised learning is the Elbow Plot. We plot K vs the total within sum of squared error and look for the “elbow” - the point at which error has reduced sufficiently before it begins to plateau within increasing K.</p>
<p align="center">
<img src="https://www.datanovia.com/en/wp-content/uploads/dn-tutorials/002-partitional-clustering/figures/006b-kmeans-clustering-k-means-optimal-clusters-wss-1.png" alt="drawing" width="500">
</p>
<p>As you can see, because there isn’t a nice upper bound to aim for such as 100% accuracy, choosing the optimum value of K is more open to interpretation. Sensible choices appear to be in the range of 2-4, in which it is up to you and your team of experts to discuss what the implications of splitting your cohort of patients, genes etc into 2-4 groups.</p>
<p>We could also plot the cluster membership against various features in the data. In the figure below, with K=3 we can see that the 3 clusters separate well across the feature “Flavanoids”, but not across the feature “Ash”, indicating that Flavanoids is an important feature in the clustering process.</p>
<p><img src="../fig/clusthist.png" class="img-fluid"></p>
<p>It’s at this point that the results of unsupervised analysis can be carried out with metrics just as in supervised analysis, but also should involve some form of Exploratory Data Analysis (EDA) to help you determine what are the optimum number of clusters for <em>your</em> purposes.</p>
<hr style="border:2px solid gray">
</section>
</section>
</section>
<section id="conclusions" class="level3">
<h3 class="anchored" data-anchor-id="conclusions">Conclusions</h3>
<p>Just like any other statistical analysis, ML results comprise of presenting certain metrics to assess the utility of a model. Supervised learning optimizes against a ground truth and so we can use metrics such as accuracy and sensitivity where the goal is to achieve 100% in such metric. Unsupervised learning is more nuanced because we don’t have aground truth - while we optimize against the total sum of squared error (and the many other variations on this theme), we often have to rely on exploratory analyses in conjunction with our use case to decide what an optimum number of clusters are.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>